b'\nYou are given a rooted unweighted tree with N nodes. The nodes are numbered from 1 to N. Node 1 is the root. You want to paint all the vertices of this tree. There are different brushes already present in each of the nodes. You can pick the brush at one node and in a single stroke paint some consecutive nodes on the path from this node to the root, starting at this node. You want to make sure that you paint each node exactly once. Now that you have the story in mind, we will shift to a more formal description:\n\nA path in this tree is good if no two different vertices on this path are at the same distance from the root. Informally, good paths refer to paths between a node and its ancestor. A path containing a single node is good.\n\n\nYou need to partition all the vertices into good paths such that the total cost (describe below) is minimized. That is, you should select a set of good paths such that every node is in exactly one of the selected paths.\n\nDepth(u) is defined to be the number of edges on the path from the root to u. So depth(1) = 0, as 1 is the root.\nh is the maximum depth among all the nodes.\n\n\nCost of a path:\nLet P be a good path. Let u be the node which is farthest away from the root, on this path. The cost of this path is the (summation of Cuw, for all w in the path) - H[u].\nCuw is equal to (C[u]*(h - depth(w)) + C[u]2), where C[u] is given to you.\nSo, put together, cost of the path = sum of ((C[u]*(h - depth(w)) + C[u]2)) - H[u]) for all nodes w in the path. \nThe total cost is the sum of costs of each of the paths that you have selected. Output the minimum total cost with which you can paint all nodes.\nInput\nThe first line of the input contains an integer T denoting the number of test cases. Description of T test cases follow.\nThe first line of each test case contains one integer N.\nThe i-th of the next N lines contain two integers each: H[i] and C[i].\nThe next N-1 lines contain two integers each: u and v denoting that there is an edge between u and v.\nOutput\nFor each test case, output one integer per line denoting the minimum total cost.\nConstraints\n\n1 \xe2\x89\xa4 T \xe2\x89\xa4 5\n1 \xe2\x89\xa4 N \xe2\x89\xa4 105\n0 \xe2\x89\xa4 C[i] \xe2\x89\xa4 105\n-1012 \xe2\x89\xa4 H[i] \xe2\x89\xa4 1012\n\nSubtasks\n\nSubtask #1 (4 points)\n\n1 \xe2\x89\xa4 N \xe2\x89\xa4 5000\nThe tree is guaranteed to be a path. In particular, Node 1 is one of the end points of this path and Nodes i and i+1 are adjacent for all 1 \xe2\x89\xa4  i < N\n\n\n\nSubtask #2 (8 points)\n\n1 \xe2\x89\xa4 N \xe2\x89\xa4 5000\n\n\n\nSubtask #3 (48 points)\n\n1 \xe2\x89\xa4 N \xe2\x89\xa4 100000\nThe tree is guaranteed to be a path. In particular, Node 1 is one of the end points of this path and Nodes i and i+1 are adjacent for all 1 \xe2\x89\xa4  i < N\n\n\n\nSubtask #4 (40 points)\n\nOriginal constraints\n\n\n\n                        Sample Input 1\n                        \n\n\n\n\n\n2\n3\n4 5\n2 3\n2 2\n1 2\n1 3\n6\n1 10\n1 8\n10 1\n1 5\n9 3\n8 2\n1 2\n1 6\n2 3\n2 4\n4 5\n\n\n\n                        Sample Output 1\n                        \n\n\n\n\n\n15\n11\n\n\nExplanation\nExample Test case 2. \n\nThe values in the brackets are (H,C)\nThe optimal solution is to paint the nodes (1,2,3) with brush 3, nodes (4,5) with brush 5 and node 6 with brush 6.\ndepth[1] = 0, depth[2] = 1, depth[3] = 2, depth[4] = 2, depth[5] = 3, depth[6] = 1\nHence, h = 3.\n C[3] * (h - depth[3]) + C[3]^2 = 1 * (3 - 2) + 1^2 = 2\nC32  = C[3] * (h - depth[2]) + C[3]^2 = 1 * (3 - 1) + 1^2 = 3\nC31 = C[3] * (h - depth[1]) + C[3]^2 = 1 * (3 - 0) + 1^2 = 4\nC55 = C[5] * (h - depth[5]) + C[5]^2 = 3 * (3 - 3) + 3^2 = 9\nC54 = C[5] * (h - depth[4]) + C[5]^2 = 3 * (3 - 2) + 3^2 = 12\nC66 = C[6] * (h - depth[6]) + C[6]^2 = 2 * (3 - 1) + 2^2 = 8\nTotal Cost = 2 + 3 + 4 + 9 + 12 + 8 - H[3] - H[5] - H[6] = 38 - 10 - 9 - 8 = 11\n\n\n\nAuthor:\n6\xe2\x98\x85tanuj_khattar\n\n\nEditorial:\nhttps://discuss.codechef.com/problems/KILLER\n\n\nTags:\n\n               \n                 DSU on Trees, Convex Hull, Dynamic Programming\n                 \n                     \n                     Advanced Algorithms, Advanced Graph Algos, Computational Geometry, Polygons, Algorithms\n                 \n               \n             \n             \n\n\n\n                        Difficulty Rating:\n                    \n\n2970\n\n\nDate Added:\n8-05-2017\n\n\nTime Limit:\n2 secs\n\n\nSource Limit:\n50000 Bytes\n\n\nLanguages:\nPYTH 3.6, JAVA, C, CPP14, PYTH, PYP3, CS2, ADA, PYPY, TEXT, PAS fpc, NODEJS, RUBY, PHP, GO, HASK, TCL, PERL, SCALA, LUA, BASH, JS, LISP sbcl, PAS gpc, BF, CLOJ, D, CAML, FORT, ASM, FS, WSPC, LISP clisp, SCM guile, PERL6, ERL, CLPS, PRLG, ICK, NICE, ICON, SCM chicken, PIKE, SCM qobi, ST, NEM\n\n\n\n\n\nSubmit\n\n'