b'\nRead problems statements in Mandarin chinese, Russian and Vietnamese as well.\nYou are given a binary tree with NN vertices numbered 11 through NN. The root of the tree is vertex 11. There are two types of vertices:\n\nnon-leaf: has exactly two sons \xe2\x80\x94 a left son and a right son\nleaf: doesn\'t have sons, but it has an integer value\n\nLet\'s denote the number of leaves by LL. It is guaranteed that the values of all leaves are pairwise distinct numbers between 11 and LL inclusive.\nTo each leaf, we can assign a string in the following way:\n\nconsider the simple path 1=v1,v2,\xe2\x80\xa6,vl1=v1,v2,\xe2\x80\xa6,vl from the root to leaf vlvl\nthe string SvlSvl assigned to leaf vlvl has length l\xe2\x88\x921l\xe2\x88\x921; for each valid ii, SiSi is \'L\' if vi+1vi+1 is the left son of vivi or \'R\' if it\'s the right son of vivi\n\nIt\'s clear that these strings are all pairwise distinct. Let\'s call the tree leaf-sorted if the following property holds for every pair of different leaves a,ba,b: SaSa is lexicographically smaller than SbSb if and only if the value of aa is smaller than the value of bb.\nYou are allowed to perform the following operation an arbitrary number of times (including zero): choose a non-leaf vertex and swap the edges to its left and right son. That is, the original left son of this vertex becomes the right son and the original right son becomes the left son (along with their whole subtrees).\nFind the minimum number of operations needed to make the tree leaf-sorted, or determine that it\'s impossible.\nInput\n\nThe first line of the input contains a single integer TT denoting the number of test cases. The description of TT test cases follows.\nThe first line of each test case contains a single integer NN.\nNN lines follow. For each ii (1\xe2\x89\xa4i\xe2\x89\xa4N1\xe2\x89\xa4i\xe2\x89\xa4N), the ii-th of these lines contains two space-separated integers ll and rr. If l=\xe2\x88\x921l=\xe2\x88\x921, vertex ii is a leaf with value rr. Otherwise, ll and rr respectively denote the left and right son of vertex ii.\n\nOutput\nFor each test case, print a single line containing one integer \xe2\x80\x94 the minimum required number of operations or \xe2\x88\x921\xe2\x88\x921 if it\'s impossible to make the tree leaf-sorted.\nConstraints\n\n1\xe2\x89\xa4T\xe2\x89\xa41,0001\xe2\x89\xa4T\xe2\x89\xa41,000\n2\xe2\x89\xa4N\xe2\x89\xa41052\xe2\x89\xa4N\xe2\x89\xa4105\n1\xe2\x89\xa4r\xe2\x89\xa4L1\xe2\x89\xa4r\xe2\x89\xa4L for each leaf (l=\xe2\x88\x921l=\xe2\x88\x921)\n1\xe2\x89\xa4l,r\xe2\x89\xa4N1\xe2\x89\xa4l,r\xe2\x89\xa4N for each non-leaf\nthe values of all leaves are pairwise distinct\nthe graph described on the input is a binary tree rooted at vertex 11\nthe sum of NN for all test cases does not exceed 2\xe2\x8b\x851052\xe2\x8b\x85105\n\nSubtasks\nSubtask #1 (30 points):\n\n1\xe2\x89\xa4T\xe2\x89\xa41001\xe2\x89\xa4T\xe2\x89\xa4100\n2\xe2\x89\xa4N\xe2\x89\xa4302\xe2\x89\xa4N\xe2\x89\xa430\n\nSubtask #2 (20 points):\n\n1\xe2\x89\xa4T\xe2\x89\xa41001\xe2\x89\xa4T\xe2\x89\xa4100\n2\xe2\x89\xa4N\xe2\x89\xa41,0002\xe2\x89\xa4N\xe2\x89\xa41,000\nthe sum of NN for all test cases does not exceed 2,0002,000\n\nSubtask #3 (50 points): original constraints\n\n                        Sample Input 1\n                        \n\n\n\n\n\n2\n5\n3 5\n-1 2\n2 4\n-1 3\n-1 1\n7\n2 3\n4 5\n6 7\n-1 1\n-1 4\n-1 3\n-1 2\n\n\n\n                        Sample Output 1\n                        \n\n\n\n\n\n1\n-1\n\n\nExplanation\nExample case 1: The leaves of this tree are vertices 2,4,52,4,5, the strings assigned to them are "LL", "LR", "R" and their values are 2,3,12,3,1. The strings are in increasing order and the corresponding values are not, so the tree isn\'t leaf-sorted. However, if we swap the left and right son of the root (vertex 11), the strings assigned to the vertices become "RL, "RR", "L", so the tree becomes leaf-sorted.\n\n\n\nAuthor:\n7\xe2\x98\x85isaf27\n\n\nEditorial:\nhttps://discuss.codechef.com/problems/TREESORT\n\n\nTags:\n\n               \n                 Trees, Binary Tree, Bottom-up, DFS\n                 \n                     \n                     Data Structures, Graphs, Tree Data Structure, Algorithms, Dynamic Programming, DP Approach, Graph Algos, Traversals\n                 \n               \n             \n             \n\n\n\n                        Difficulty Rating:\n                    \n\n2177\n\n\nDate Added:\n23-06-2018\n\n\nTime Limit:\n1 secs\n\n\nSource Limit:\n50000 Bytes\n\n\nLanguages:\nPYTH 3.6, JAVA, C, CPP14, PYTH, PYP3, CS2, ADA, PYPY, TEXT, PAS fpc, NODEJS, RUBY, PHP, GO, HASK, TCL, kotlin, PERL, SCALA, LUA, BASH, JS, rust, LISP sbcl, PAS gpc, BF, CLOJ, D, CAML, swift, FORT, ASM, FS, WSPC, LISP clisp, SCM guile, PERL6, ERL, CLPS, PRLG, ICK, NICE, ICON, COB, SCM chicken, PIKE, SCM qobi, ST, NEM\n\n\n\n\n\nSubmit\n\n'