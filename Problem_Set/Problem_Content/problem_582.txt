b'\n\nConsider an infinitely large chess table.\nFrom the cell (0, 0), our knight has to move to the cell (X, Y) by the rule:\nour knight could only move from a cell (u, v) to the cell (u+AX, v+AY) or (u+BX, v+BY) in one move.\nNote that it may be different from ordinary knight\'s move of chess.\n\nIn addition, there is K blocked cell(s) on the table where the knight could not move on.\n\nYour task is to count how many distinct ways the knight could complete his mission.\nTwo ways are called "distinct" if and only if they have different numbers of steps or there exists i such that they are in different cells after i-th step.\nNote that our knight may continue to move after he reaches the cell (X, Y).\n\nInput\nThe first line contains an integer T, denoting the number of test cases. Each test case is described as follows:\n\nThe first line contains 3 integer X, Y, K.\nThe second line contains 4 integers AX, AY, BX, BY.\nThe third line contains K pair(s) of integers, each represents co-ordinate of a blocked cell. This line does not exist if K = 0.\n\nOutput\n\nFor each test case, output on a line the number of ways found modulo 1000000007 (109+7).\nIf there are infinitely many ways, then output -1 instead.\n\nConstraints\n\n1 \xe2\x89\xa4 T \xe2\x89\xa4 5\n0 \xe2\x89\xa4 K \xe2\x89\xa4 15\nThe absolute values of all other input values are at most 500.\n(0, 0) is not a blocked cell.\n(X, Y) is not a blocked cell.\n\nExample\nInput:\n3\n3 3 0\n1 2 2 1\n9 9 2\n1 2 2 1\n1 2 6 6\n1 1 0\n0 0 0 0\n\nOutput:\n2\n4\n0\n\n\n\n\nExplanations:\n\n\nIn the first and second examples, our knight\'s move is the similar to ordinary knight\'s, but only 2 directions are allowed. In the first example, there are 2 ways (0, 0) -> (1, 2) -> (3, 3) and (0, 0) -> (2, 1) -> (3, 3).\n\n\nIn the third example, our knight\'s cannot move toward, so our knight\'s cannot complete his mission.\n\n\n\n\nAuthor:\nanhdq_adm\n\n\nTester:\n6\xe2\x98\x85laycurse\n\n\nEditorial:\nhttps://discuss.codechef.com/problems/KNGHTMOV\n\n\nTags:\n\n               \n                 Modulo Multiplicative Inverse, Inclusion Exclusion Principle, Gaussian Elimination, DP Approach, Cycles\n                 \n                     \n                     Mathematics, Modular Arithmetic, Set Theory, Matrices, Algorithms, Dynamic Programming, Graph Algos\n                 \n               \n             \n             \n\n\n\n                        Difficulty Rating:\n                    \n\n2647\n\n\nDate Added:\n20-07-2012\n\n\nTime Limit:\n0.9 secs\n\n\nSource Limit:\n50000 Bytes\n\n\nLanguages:\nPYTH 3.6, JAVA, C, CPP14, PYTH, PYP3, CS2, ADA, TEXT, PAS fpc, NODEJS, RUBY, PHP, GO, HASK, TCL, PERL, SCALA, LUA, BASH, JS, LISP sbcl, PAS gpc, BF, CLOJ, D, CAML, FORT, ASM, FS, WSPC, LISP clisp, SCM guile, PERL6, ERL, CLPS, PRLG, ICK, NICE, ICON, PIKE, SCM qobi, ST, NEM\n\n\n\n\n\nSubmit\n\n'