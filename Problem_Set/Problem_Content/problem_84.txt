b'\nYou are given an array A=[A1,A2,\xe2\x80\xa6,AN]A=[A1,A2,\xe2\x80\xa6,AN], consisting of NN integers. In one move, you can take two adjacent numbers AiAi and Ai+1Ai+1, delete them, and then insert the number Ai\xe2\x88\xa7Ai+1Ai\xe2\x88\xa7Ai+1 at the deleted position. Here, \xe2\x88\xa7\xe2\x88\xa7 denotes bitwise AND. Note that after this operation, the length of the array decreases by one.\nFormally, as long as |A|>1|A|>1 (where |A||A| denotes the current length of AA), you can pick an index 1\xe2\x89\xa4i<|A|1\xe2\x89\xa4i<|A| and transform AA into [A1,A2,\xe2\x80\xa6,Ai\xe2\x88\x921,Ai\xe2\x88\xa7Ai+1,Ai+2,\xe2\x80\xa6,A|A|][A1,A2,\xe2\x80\xa6,Ai\xe2\x88\x921,Ai\xe2\x88\xa7Ai+1,Ai+2,\xe2\x80\xa6,A|A|].\nFind the minimum number of moves required to make all numbers in the resulting array equal.\nInput Format\n\nThe first line of input contains an integer TT \xe2\x80\x94 the number of test cases you need to solve.\nThe first line of each test case contains one integer NN, the size of the array.\nThe second line of each test case contains NN space-separated integers A1,\xe2\x80\xa6,ANA1,\xe2\x80\xa6,AN \xe2\x80\x94 the elements of the array AA.\n\nOutput Format\nFor each test case, output on a new line the minimum number of moves required to make all numbers equal.\nConstraints\n\n1\xe2\x89\xa4T\xe2\x89\xa41061\xe2\x89\xa4T\xe2\x89\xa4106\n2\xe2\x89\xa4N\xe2\x89\xa41062\xe2\x89\xa4N\xe2\x89\xa4106\nSum of NN over all test cases is at most 106106.\n0\xe2\x89\xa4Ai<2300\xe2\x89\xa4Ai<230\n\nSubtasks\n\nSubtask 1 (20 points):\n0\xe2\x89\xa4Ai\xe2\x89\xa42550\xe2\x89\xa4Ai\xe2\x89\xa4255\nSum of NN over all test cases is at most 255255.\nSubtask 2 (30 points):\nSum of NN over all test cases is at most 20002000.\nSubtask 3 (50 points):\nOriginal constraints.\n\n\n                        Sample Input 1\n                        \n\n\n\n\n\n4\n4\n0 0 0 1\n2\n1 1\n6\n1 2 3 4 5 6\n4\n2 28 3 22\n\n\n\n                        Sample Output 1\n                        \n\n\n\n\n\n1\n0\n4\n3\n\n\nExplanation\nTest case 11: Choose i=3i=3 to make the array [0,0,0\xe2\x88\xa71]=[0,0,0][0,0,0\xe2\x88\xa71]=[0,0,0].\nTest case 22: All elements of the array are already equal.\nTest case 33: One possible sequence of moves is as follows:\n\nChoose i=1i=1, making the array [1\xe2\x88\xa72,3,4,5,6]=[0,3,4,5,6][1\xe2\x88\xa72,3,4,5,6]=[0,3,4,5,6]\nChoose i=2i=2, making the array [0,0,5,6][0,0,5,6]\nChoose i=3i=3, making the array [0,0,4][0,0,4]\nChoose i=2i=2, making the array [0,0][0,0]\n\nIt can be verified that in this case, making every element equal using 33 or fewer moves is impossible.\n\n\n\nAuthor:\nyahor_adm\n\n\nEditorial:\nhttps://discuss.codechef.com/problems/ANDEQ\n\n\nTags:\n\n               \n                 Bitmasking, Greedy\n                 \n                     \n                     Mathematics, Bit Manipulation, Algorithms\n                 \n               \n             \n             \n\n\n\n                        Difficulty Rating:\n                    \n\n1945\n\n\nDate Added:\n13-05-2022\n\n\nTime Limit:\n1 secs\n\n\nSource Limit:\n50000 Bytes\n\n\nLanguages:\nCPP17, PYTH 3.6, JAVA, C, CPP14, PYTH, PYP3, CS2, ADA, PYPY, TEXT, PAS fpc, NODEJS, RUBY, PHP, GO, HASK, TCL, kotlin, PERL, SCALA, LUA, BASH, JS, rust, LISP sbcl, PAS gpc, BF, CLOJ, R, D, CAML, swift, FORT, ASM, FS, WSPC, LISP clisp, SQL, SCM guile, PERL6, ERL, CLPS, PRLG, SQLQ, ICK, NICE, ICON, COB, SCM chicken, PIKE, SCM qobi, ST, NEM\n\n\n\n\n\nSubmit\n\n'