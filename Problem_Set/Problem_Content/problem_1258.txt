b"\nThey don't call it Vindhya Maze for nothing!\nVindhya consists of a straight line of buildings, connected by a common path. They are all uniformly spaced as well, and it takes you kk meters to walk from one building to a neighboring building.\nVindhya is long overdue for a renovation, so the administration decided to make the pathways a bit more interesting.\nEach building has been assigned an ID, but due to poor planning, multiple buildings can have the same ID.\nThe administration is constructing more pathways. A path from building ii to building jj is constructed if the lcmlcm of the IDs of buildings (i,i+1,\xe2\x80\xa6j\xe2\x88\x921,j)(i,i+1,\xe2\x80\xa6j\xe2\x88\x921,j) is equal to the maximum ID in the same range. The path will be lcm(i,i+1,\xe2\x80\xa6,j\xe2\x88\x921,j)lcm(i,i+1,\xe2\x80\xa6,j\xe2\x88\x921,j) meters long. \nAfter building all these roads, they realized that they've made walking around Vindhya a bit too long and complex, so they've asked you to help them decide which paths to remove (you can remove the original pathways as well) such that you can still reach all other buildings from every building, while minimizing the sum of the lengths of the paths remaining.\nInput Format\n\nThe first line contains two integers, NN  and kk , the number of buildings and the distance between two neighboring buildings respectively.\nThe next line contains NN integers x1,x2,x3,\xe2\x80\xa6,xnx1,x2,x3,\xe2\x80\xa6,xn,  the IDs of the buildings (not necessarily unique).\n\nOutput Format\nOutput a single integer, the minimum sum of the length of paths remaining while ensuring that from every building you can reach every other building.\nConstraints\n\n2\xe2\x89\xa4N\xe2\x89\xa41052\xe2\x89\xa4N\xe2\x89\xa4105\n1\xe2\x89\xa4k\xe2\x89\xa41091\xe2\x89\xa4k\xe2\x89\xa4109\n1\xe2\x89\xa4xi\xe2\x89\xa41091\xe2\x89\xa4xi\xe2\x89\xa4109\n\n\n                        Sample Input 1\n                        \n\n\n\n\n\n4 10\n4 2 6 3\n\n\n\n                        Sample Output 1\n                        \n\n\n\n\n\n16\n\n\nExplanation\nThere will be new paths between indices (1,2)(1,2), (2,3)(2,3), (3,4)(3,4), (2,4)(2,4), with weights 44, 66, 66, and 66 respectively.\nYou can keep the paths (1,2)(1,2), (2,3)(2,3), (3,4)(3,4) to get a minimum cost of 1616.\nHack case note\nFind the buggy solution to this problem on GitHub or Drive.\nThis problem is part of the DeCode contest, wherein you are given a problem (as given above) and its buggy solution (link in contest announcement). You have to submit a program that outputs a hack case to the buggy solution or you can submit the hack case directly as a text file (select TEXT as language while submitting). Your program's output or the hack case should satisfy the input constraints of the above problem.\n\n\n\nAuthor:\n6\xe2\x98\x85awesome_amul\n\n\nEditorial:\nhttps://discuss.codechef.com/problems/VINTRBL\n\n\nTags:\n\n               \n                 awesome_amul, disjoint-set-union, math, medium-hard\n                 \n               \n             \n             \n\n\n\n                        Difficulty Rating:\n                    \n\nN/A\n\n\nDate Added:\n4-03-2022\n\n\nTime Limit:\n3 secs\n\n\nSource Limit:\n50000 Bytes\n\n\nLanguages:\nCPP17, PYTH 3.6, JAVA, C, CPP14, PYTH, PYP3, CS2, ADA, PYPY, TEXT, PAS fpc, NODEJS, RUBY, PHP, GO, HASK, TCL, kotlin, PERL, SCALA, LUA, BASH, JS, rust, LISP sbcl, PAS gpc, BF, CLOJ, R, D, CAML, swift, FORT, ASM, FS, WSPC, LISP clisp, SQL, SCM guile, PERL6, ERL, CLPS, PRLG, SQLQ, ICK, NICE, ICON, COB, SCM chicken, PIKE, SCM qobi, ST, NEM\n\n\n\n\n\nSubmit\n\n"